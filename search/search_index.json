{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Hyperlinked Twin","text":"<p>This website is a hyperlinked twin of a Spoofax language project code repository. The website navigation hierarchy corresponds to the repository file hierarchy, and the code displayed on each page is a verbatim copy of the raw code in the corresponding file.</p> <p>Hyperlinked twins support precise name-based code navigation online in ordinary web browsers:</p> <ul> <li>Simply click on a name reference to jump to the first declaration of the name.</li> <li>Click on a declaration to display a modal with links to all the references to the declaration.<sup>1</sup></li> </ul> <p>The sources of the webpages were generated using Spoofax from the analysed language project. The hyperlinks added to names were generated from the name binding analysis used by Spoofax, and the syntax highlighting corresponds closely to that displayed when browsing files in Spoofax.</p> <p>The aim is for a future release of Spoofax to support generation of hyperlinked twin websites with code in all Spoofax meta-languages.</p> <ol> <li> <p>When there is only one reference to a declaration, \u200b    clicking on the declaration jumps directly to the reference. \u200b    When there are no references to a declaration, \u200b    clicking on it has no effect.\u00a0\u21a9</p> </li> </ol>"},{"location":"org.metaborg.lang.tiger.statix/","title":"Tiger","text":"<p> metaborgcube/metaborg-tiger/org.metaborg.lang.tiger.statix</p> <p>From the Tiger Language Reference Manual:</p> <p>This document describes the Tiger language defined in Andrew Appel\u2019s book Modern Compiler Implementation in Java (Cambridge University Press, 1998).</p> <p>The Tiger language is a small, imperative language with integer and string variables, arrays, records, and nested functions. Its syntax resembles some functional languages.</p>"},{"location":"org.metaborg.lang.tiger.statix/#reference","title":"Reference","text":"<p>Phil Misteli: Renaming for Everyone: Language-parametric Renaming in Spoofax, Master thesis, TU Delft, 2021</p>"},{"location":"org.metaborg.lang.tiger.statix/#syntax","title":"Syntax","text":"<p><code>syntax/Tiger.sdf3</code></p> <p>The syntax of Tiger is specified in SDF3.</p>"},{"location":"org.metaborg.lang.tiger.statix/#name-binding","title":"Name binding","text":"<p><code>trans/static-semantics.stx</code></p> <p>The name binding of Tiger is specified in Statix.</p> <p>To do</p> <ul> <li> Check for broken links</li> <li> Make Statix highlighting consistent with that specified in the Statix language project.</li> </ul>"},{"location":"org.metaborg.lang.tiger.statix/src-gen/statix/signatures/ATerms-sig.stx/","title":"<code>ATerms-sig.stx</code>","text":"<pre><code>module signatures/ATerms-sig\n\nimports\n\nsignature\n\n  sorts\n    Cons = string\n    Int = string\n    String = string\n    StringChar = string\n    Term\n\n  constructors\n    Term-Plhdr : Term\n\nsignature\n\n  constructors\n    Str : String -&gt; Term\n    Int : Int -&gt; Term\n    App : Cons * list(Term) -&gt; Term\n    List : list(Term) -&gt; Term\n    Tuple : list(Term) -&gt; Term\n</code></pre> \u00d7"},{"location":"org.metaborg.lang.tiger.statix/src-gen/statix/signatures/ATerms-sig.stx/#modal-h2","title":"ATerms-sig.stx","text":""},{"location":"org.metaborg.lang.tiger.statix/src-gen/statix/signatures/Arrays-sig.stx/","title":"<code>Arrays-sig.stx</code>","text":"<pre><code>module signatures/Arrays-sig\n\nimports\n  signatures/Base-sig\n\nsignature\n\n  sorts\n\n  constructors\n\nsignature\n\n  constructors\n    Array : ID * Exp * Exp -&gt; Exp\n    ArrayTy : ID -&gt; Type\n    Subscript : LValue * Exp -&gt; LValue\n</code></pre> \u00d7"},{"location":"org.metaborg.lang.tiger.statix/src-gen/statix/signatures/Arrays-sig.stx/#modal-h2","title":"Arrays-sig.stx","text":""},{"location":"org.metaborg.lang.tiger.statix/src-gen/statix/signatures/Base-sig.stx/","title":"<code>Base-sig.stx</code>","text":"<pre><code>module signatures/Base-sig\n\nimports\n\nsignature\n\n  sorts\n    Dec\n    Exp\n    LValue\n    Type\n    Var\n    ID = string\n\n  constructors\n    Dec-Plhdr : Dec\n    Exp-Plhdr : Exp\n    LValue-Plhdr : LValue\n    Type-Plhdr : Type\n    Var-Plhdr : Var\n\nsignature\n\n  constructors\n</code></pre> \u00d7"},{"location":"org.metaborg.lang.tiger.statix/src-gen/statix/signatures/Base-sig.stx/#modal-h2","title":"Base-sig.stx","text":""},{"location":"org.metaborg.lang.tiger.statix/src-gen/statix/signatures/Bindings-sig.stx/","title":"<code>Bindings-sig.stx</code>","text":"<pre><code>module signatures/Bindings-sig\n\nimports\n  signatures/Base-sig\n\nsignature\n\n  sorts\n    Declarations\n\n  constructors\n    Declarations-Plhdr : Declarations\n\nsignature\n\n  constructors\n    Let : list(Dec) * list(Exp) -&gt; Exp\n    Declarations : list(Dec) -&gt; Declarations\n</code></pre> \u00d7"},{"location":"org.metaborg.lang.tiger.statix/src-gen/statix/signatures/Bindings-sig.stx/#modal-h2","title":"Bindings-sig.stx","text":""},{"location":"org.metaborg.lang.tiger.statix/src-gen/statix/signatures/Control-Flow-sig.stx/","title":"<code>Control-Flow-sig.stx</code>","text":"<pre><code>module signatures/Control-Flow-sig\n\nimports\n  signatures/Base-sig\n\nsignature\n\n  sorts\n\n  constructors\n\nsignature\n\n  constructors\n    Seq : list(Exp) -&gt; Exp\n    If : Exp * Exp * Exp -&gt; Exp\n    IfThen : Exp * Exp -&gt; Exp\n    While : Exp * Exp -&gt; Exp\n    For : Var * Exp * Exp * Exp -&gt; Exp\n    Break : Exp\n    Assign : LValue * Exp -&gt; Exp\n</code></pre> \u00d7"},{"location":"org.metaborg.lang.tiger.statix/src-gen/statix/signatures/Control-Flow-sig.stx/#modal-h2","title":"Control-Flow-sig.stx","text":""},{"location":"org.metaborg.lang.tiger.statix/src-gen/statix/signatures/Functions-sig.stx/","title":"<code>Functions-sig.stx</code>","text":"<pre><code>module signatures/Functions-sig\n\nimports\n  signatures/Base-sig\n\nsignature\n\n  sorts\n    FArg\n\n  constructors\n    FArg-Plhdr : FArg\n\nsignature\n\n  constructors\n    ProcDec : ID * list(FArg) * Exp -&gt; Dec\n    FunDec : ID * list(FArg) * Type * Exp -&gt; Dec\n    FArg : ID * Type -&gt; FArg\n    Call : ID * list(Exp) -&gt; Exp\n</code></pre> \u00d7"},{"location":"org.metaborg.lang.tiger.statix/src-gen/statix/signatures/Functions-sig.stx/#modal-h2","title":"Functions-sig.stx","text":""},{"location":"org.metaborg.lang.tiger.statix/src-gen/statix/signatures/Identifiers-sig.stx/","title":"<code>Identifiers-sig.stx</code>","text":"<pre><code>module signatures/Identifiers-sig\n\nimports\n  signatures/Base-sig\n\nsignature\n\n  sorts\n\n  constructors\n\nsignature\n\n  constructors\n</code></pre> \u00d7"},{"location":"org.metaborg.lang.tiger.statix/src-gen/statix/signatures/Identifiers-sig.stx/#modal-h2","title":"Identifiers-sig.stx","text":""},{"location":"org.metaborg.lang.tiger.statix/src-gen/statix/signatures/Numbers-sig.stx/","title":"<code>Numbers-sig.stx</code>","text":"<pre><code>module signatures/Numbers-sig\n\nimports\n  signatures/Base-sig\n\nsignature\n\n  sorts\n    IntConst = string\n\n  constructors\n\nsignature\n\n  constructors\n    Int : IntConst -&gt; Exp\n    Uminus : Exp -&gt; Exp\n    Times : Exp * Exp -&gt; Exp\n    Divide : Exp * Exp -&gt; Exp\n    Plus : Exp * Exp -&gt; Exp\n    Minus : Exp * Exp -&gt; Exp\n    Eq : Exp * Exp -&gt; Exp\n    Neq : Exp * Exp -&gt; Exp\n    Gt : Exp * Exp -&gt; Exp\n    Lt : Exp * Exp -&gt; Exp\n    Geq : Exp * Exp -&gt; Exp\n    Leq : Exp * Exp -&gt; Exp\n    And : Exp * Exp -&gt; Exp\n    Or : Exp * Exp -&gt; Exp\n</code></pre> \u00d7"},{"location":"org.metaborg.lang.tiger.statix/src-gen/statix/signatures/Numbers-sig.stx/#modal-h2","title":"Numbers-sig.stx","text":""},{"location":"org.metaborg.lang.tiger.statix/src-gen/statix/signatures/Records-sig.stx/","title":"<code>Records-sig.stx</code>","text":"<pre><code>module signatures/Records-sig\n\nimports\n  signatures/Base-sig\n\nsignature\n\n  sorts\n    Field\n    InitField\n\n  constructors\n    Field-Plhdr : Field\n    InitField-Plhdr : InitField\n\nsignature\n\n  constructors\n    RecordTy : list(Field) -&gt; Type\n    Field : ID * ID -&gt; Field\n    NilExp : Exp\n    Record : ID * list(InitField) -&gt; Exp\n    InitField : ID * Exp -&gt; InitField\n    FieldVar : LValue * ID -&gt; LValue\n</code></pre> \u00d7"},{"location":"org.metaborg.lang.tiger.statix/src-gen/statix/signatures/Records-sig.stx/#modal-h2","title":"Records-sig.stx","text":""},{"location":"org.metaborg.lang.tiger.statix/src-gen/statix/signatures/Strings-sig.stx/","title":"<code>Strings-sig.stx</code>","text":"<pre><code>module signatures/Strings-sig\n\nimports\n  signatures/Base-sig\n\nsignature\n\n  sorts\n    StrConst = string\n    StrChar = string\n\n  constructors\n\nsignature\n\n  constructors\n    String : StrConst -&gt; Exp\n</code></pre> \u00d7"},{"location":"org.metaborg.lang.tiger.statix/src-gen/statix/signatures/Strings-sig.stx/#modal-h2","title":"Strings-sig.stx","text":""},{"location":"org.metaborg.lang.tiger.statix/src-gen/statix/signatures/Tiger-sig.stx/","title":"<code>Tiger-sig.stx</code>","text":"<pre><code>module signatures/Tiger-sig\n\nimports\n  signatures/Base-sig\n  signatures/Whitespace-sig\n  signatures/Types-sig\n  signatures/Identifiers-sig\n  signatures/Bindings-sig\n  signatures/Variables-sig\n  signatures/Functions-sig\n  signatures/Numbers-sig\n  signatures/Strings-sig\n  signatures/Records-sig\n  signatures/Arrays-sig\n  signatures/Control-Flow-sig\n\nsignature\n\n  sorts\n    Module\n\n  constructors\n    Module-Plhdr : Module\n\nsignature\n\n  constructors\n    Mod : Exp -&gt; Module\n</code></pre> \u00d7"},{"location":"org.metaborg.lang.tiger.statix/src-gen/statix/signatures/Tiger-sig.stx/#modal-h2","title":"Tiger-sig.stx","text":""},{"location":"org.metaborg.lang.tiger.statix/src-gen/statix/signatures/Types-sig.stx/","title":"<code>Types-sig.stx</code>","text":"<pre><code>module signatures/Types-sig\n\nimports\n  signatures/Base-sig\n\nsignature\n\n  sorts\n\n  constructors\n\nsignature\n\n  constructors\n    TypeDec : ID * Type -&gt; Dec\n    Tid : ID -&gt; Type\n</code></pre> \u00d7"},{"location":"org.metaborg.lang.tiger.statix/src-gen/statix/signatures/Types-sig.stx/#modal-h2","title":"Types-sig.stx","text":""},{"location":"org.metaborg.lang.tiger.statix/src-gen/statix/signatures/Variables-sig.stx/","title":"<code>Variables-sig.stx</code>","text":"<pre><code>module signatures/Variables-sig\n\nimports\n  signatures/Base-sig\n\nsignature\n\n  sorts\n\n  constructors\n\nsignature\n\n  constructors\n    VarDec : ID * Type * Exp -&gt; Dec\n    VarDecNoType : ID * Exp -&gt; Dec\n    Var : ID -&gt; Var\n    Var2LValue : Var -&gt; LValue\n    LValue2Exp : LValue -&gt; Exp\n</code></pre> \u00d7"},{"location":"org.metaborg.lang.tiger.statix/src-gen/statix/signatures/Variables-sig.stx/#modal-h2","title":"Variables-sig.stx","text":""},{"location":"org.metaborg.lang.tiger.statix/src-gen/statix/signatures/Whitespace-sig.stx/","title":"<code>Whitespace-sig.stx</code>","text":"<pre><code>module signatures/Whitespace-sig\n\nimports\n\nsignature\n\n  sorts\n    CommentChar = string\n    InsideComment = string\n    SingleLineComment = string\n    NewLineEOF = string\n    EOF = string\n\n  constructors\n\nsignature\n\n  constructors\n</code></pre> \u00d7"},{"location":"org.metaborg.lang.tiger.statix/src-gen/statix/signatures/Whitespace-sig.stx/#modal-h2","title":"Whitespace-sig.stx","text":""},{"location":"org.metaborg.lang.tiger.statix/src-gen/statix/signatures/permissive-water-sig.stx/","title":"<code>permissive-water-sig.stx</code>","text":"<pre><code>module signatures/permissive-water-sig\n\nimports\n\nsignature\n\n  sorts\n    WATER = string\n    WATERTOKEN = string\n    WATERTOKENSTART = string\n    WATERTOKENSEPARATOR = string\n\n  constructors\n\nsignature\n\n  constructors\n</code></pre> \u00d7"},{"location":"org.metaborg.lang.tiger.statix/src-gen/statix/signatures/permissive-water-sig.stx/#modal-h2","title":"permissive-water-sig.stx","text":""},{"location":"org.metaborg.lang.tiger.statix/src-gen/syntax/permissive-water.sdf3/","title":"<code>permissive-water.sdf3</code>","text":"<pre><code>module permissive-water\n\n// Key idea: WATER is the inverse of LAYOUT\n\ncontext-free syntax\n  // Allow WATER on places where LAYOUT may occur\n  LAYOUT.WATER = WATER\n\nlexical sorts\n  WATER\n  WATERTOKEN\n  WATERTOKENSTART\n  WATERTOKENSEPARATOR\n\nlexical syntax\n  // Separate water regions into smaller chunks for recovery costs calculation\n  WATER = WATERTOKEN\n  WATER = WATERTOKENSEPARATOR\n\n  // Allow to skip over identifier strings\n  WATERTOKEN      = WATERTOKENSTART [A-Za-z0-9\\_]*\n  WATERTOKENSTART = [A-Za-z0-9\\_] {recover}\n\n  // Allow to skip over special characters that are neither part of identifiers nor whitespace characters\n  WATERTOKENSEPARATOR = ~[A-Za-z0-9\\_\\ \\t\\12\\r\\n\\*] {recover}\n\nlexical restrictions\n  WATERTOKEN -/- [A-Za-z0-9\\_]\n</code></pre> \u00d7"},{"location":"org.metaborg.lang.tiger.statix/src-gen/syntax/permissive-water.sdf3/#modal-h2","title":"permissive-water.sdf3","text":""},{"location":"org.metaborg.lang.tiger.statix/syntax/ATerms.sdf3/","title":"<code>ATerms.sdf3</code>","text":"<p> pdmosses/metaborg-tiger/org.metaborg.lang.tiger.statix/syntax/ATerms.sdf3</p> <pre><code>module ATerms\n\nlexical sorts Cons Int String StringChar\n\nlexical syntax\n\n   Cons       = [a-zA-Z][a-zA-Z0-9]*\n   Cons       = String\n   Int        = [0-9]+\n   String     = \"\\\"\" StringChar* \"\\\"\"\n   StringChar = ~[\\\"\\\\]\n   StringChar = \"\\\\\" [\\\"\\\\]\n\ncontext-free sorts Term\ncontext-free syntax\n\n   Term.Str   = &lt;&lt;String&gt;&gt;\n   Term.Int   = &lt;&lt;Int&gt;&gt;\n   Term.App   = &lt;&lt;Cons&gt;(&lt;{Term \",\"}*&gt;)&gt;\n   Term.List  = &lt;[&lt;{Term \",\"}*&gt;]&gt;\n   Term.Tuple = &lt;(&lt;{Term \",\"}*&gt;)&gt;\n\n</code></pre> \u00d7"},{"location":"org.metaborg.lang.tiger.statix/syntax/ATerms.sdf3/#modal-h2","title":"ATerms.sdf3","text":""},{"location":"org.metaborg.lang.tiger.statix/syntax/Arrays.sdf3/","title":"<code>Arrays.sdf3</code>","text":"<p> pdmosses/metaborg-tiger/org.metaborg.lang.tiger.statix/syntax/Arrays.sdf3</p> <pre><code>module Arrays\n\nimports Base\n\n// Arrays\ncontext-free syntax\n\n  Exp.Array = &lt;&lt;ID&gt;[&lt;Exp&gt;] of &lt;Exp&gt;&gt;\n\n  Type.ArrayTy = &lt;array of &lt;ID&gt;&gt;\n\n  LValue.Subscript = &lt;&lt;LValue&gt;[&lt;Exp&gt;]&gt;\n\n</code></pre> \u00d7"},{"location":"org.metaborg.lang.tiger.statix/syntax/Arrays.sdf3/#modal-h2","title":"Arrays.sdf3","text":""},{"location":"org.metaborg.lang.tiger.statix/syntax/Base.sdf3/","title":"<code>Base.sdf3</code>","text":"<p> pdmosses/metaborg-tiger/org.metaborg.lang.tiger.statix/syntax/Base.sdf3</p> <pre><code>module Base\n\nsorts Dec Exp LValue\n\nsorts Type\n\nsorts Var\n\nlexical sorts ID\n\n</code></pre> \u00d7"},{"location":"org.metaborg.lang.tiger.statix/syntax/Base.sdf3/#modal-h2","title":"Base.sdf3","text":""},{"location":"org.metaborg.lang.tiger.statix/syntax/Bindings.sdf3/","title":"<code>Bindings.sdf3</code>","text":"<p> pdmosses/metaborg-tiger/org.metaborg.lang.tiger.statix/syntax/Bindings.sdf3</p> <pre><code>module Bindings\n\nimports Base\n\nsorts Declarations\n\ncontext-free syntax\n\n  Exp.Let = &lt;\n    let\n      &lt;{Dec \"\\n\"}*&gt;\n     in\n      &lt;{Exp \";\\n\"}*&gt;\n    end\n  &gt;\n\n  Declarations.Declarations = &lt;\n    declarations &lt;{Dec \"\\n\"}*&gt;\n  &gt;\n\n\n\n\n</code></pre> \u00d7"},{"location":"org.metaborg.lang.tiger.statix/syntax/Bindings.sdf3/#modal-h2","title":"Bindings.sdf3","text":""},{"location":"org.metaborg.lang.tiger.statix/syntax/Control-Flow.sdf3/","title":"<code>Control-Flow.sdf3</code>","text":"<p> pdmosses/metaborg-tiger/org.metaborg.lang.tiger.statix/syntax/Control-Flow.sdf3</p> <pre><code>module Control-Flow\n\nimports Base\n\ncontext-free syntax\n\n  Exp.Seq = &lt;\n    (\n      &lt;{Exp \";\\n\"}*&gt;\n    )\n  &gt;\n\n  Exp.If = &lt;\n    if &lt;Exp&gt; then\n      &lt;Exp&gt;\n    else\n      &lt;Exp&gt;\n  &gt;\n\n  Exp.IfThen = &lt;\n    if &lt;Exp&gt; then\n      &lt;Exp&gt;\n  &gt;\n\n  Exp.While = &lt;\n    while &lt;Exp&gt; do\n      &lt;Exp&gt;\n  &gt;\n\n  Exp.For = &lt;\n    for &lt;Var&gt; := &lt;Exp&gt; to &lt;Exp&gt; do\n      &lt;Exp&gt;\n  &gt;\n\n  Exp.Break = &lt;break&gt;\n\n  Exp.Assign = &lt;&lt;LValue&gt; := &lt;Exp&gt;&gt;\n\ncontext-free priorities\n\n  {\n    Exp.Assign\n  } &gt; { right:\n    Exp.If\n    Exp.IfThen\n    Exp.While\n    Exp.For\n  }\n\n</code></pre> \u00d7"},{"location":"org.metaborg.lang.tiger.statix/syntax/Control-Flow.sdf3/#modal-h2","title":"Control-Flow.sdf3","text":""},{"location":"org.metaborg.lang.tiger.statix/syntax/Functions.sdf3/","title":"<code>Functions.sdf3</code>","text":"<p> pdmosses/metaborg-tiger/org.metaborg.lang.tiger.statix/syntax/Functions.sdf3</p> <pre><code>module Functions\n\nimports Base\n\nsorts FArg\ncontext-free syntax\n\n  Dec.ProcDec = &lt;\n    function &lt;ID&gt;(&lt;{FArg \", \"}*&gt;) =\n      &lt;Exp&gt;\n  &gt;\n\n  Dec.FunDec = &lt;\n    function &lt;ID&gt;(&lt;{FArg \", \"}*&gt;) : &lt;Type&gt; =\n      &lt;Exp&gt;\n  &gt;\n\n  FArg.FArg = &lt;&lt;ID&gt; : &lt;Type&gt;&gt;\n\n  Exp.Call = &lt;&lt;ID&gt;(&lt;{Exp \", \"}*&gt;)&gt;\n\n</code></pre> \u00d7"},{"location":"org.metaborg.lang.tiger.statix/syntax/Functions.sdf3/#modal-h2","title":"Functions.sdf3","text":""},{"location":"org.metaborg.lang.tiger.statix/syntax/Identifiers.sdf3/","title":"<code>Identifiers.sdf3</code>","text":"<p> pdmosses/metaborg-tiger/org.metaborg.lang.tiger.statix/syntax/Identifiers.sdf3</p> <pre><code>module Identifiers\n\nimports Base\n\nlexical syntax\n\n  ID = [a-zA-Z] [a-zA-Z0-9\\_]*\n  ID = \"_main\"\n\nlexical restrictions\n\n  ID -/- [a-zA-Z0-9\\_]\n\nlexical syntax\n\n  ID = \"label\"        {reject}\n  ID = \"goto\"         {reject}\n  ID = \"declarations\" {reject}\n  ID = \"true\"         {reject}\n  ID = \"false\"        {reject}\n\nlexical syntax\n\n  ID = \"array\"        {reject}\n  ID = \"if\"           {reject}\n  ID = \"then\"         {reject}\n  ID = \"else\"         {reject}\n  ID = \"while\"        {reject}\n  ID = \"for\"          {reject}\n  ID = \"to\"           {reject}\n  ID = \"do\"           {reject}\n  ID = \"let\"          {reject}\n  ID = \"in\"           {reject}\n  ID = \"end\"          {reject}\n  ID = \"of\"           {reject}\n  ID = \"break\"        {reject}\n  ID = \"nil\"          {reject}\n  ID = \"function\"     {reject}\n  ID = \"var\"          {reject}\n  ID = \"type\"         {reject}\n  ID = \"import\"       {reject}\n  ID = \"primitive\"    {reject}\n\nlexical syntax\n\n  ID = \"class\"        {reject}\n  ID = \"extends\"      {reject}\n  ID = \"method\"       {reject}\n  ID = \"new\"          {reject}\n\n</code></pre> \u00d7"},{"location":"org.metaborg.lang.tiger.statix/syntax/Identifiers.sdf3/#modal-h2","title":"Identifiers.sdf3","text":""},{"location":"org.metaborg.lang.tiger.statix/syntax/Numbers.sdf3/","title":"<code>Numbers.sdf3</code>","text":"<p> pdmosses/metaborg-tiger/org.metaborg.lang.tiger.statix/syntax/Numbers.sdf3</p> <pre><code>module Numbers\n\nimports Base\n\nlexical sorts IntConst\nlexical syntax\n\n  IntConst = [0-9]+\n\nlexical restrictions\n\n  // Ensure greedy matching for lexicals\n\n  IntConst  -/- [0-9]\n\n\ncontext-free syntax\n\n  Exp.Int     = IntConst\n\n  Exp.Uminus  = [- [Exp]]\n  Exp.Times   = [[Exp] * [Exp]]   {left}\n  Exp.Divide  = [[Exp] / [Exp]]   {left}\n  Exp.Plus    = [[Exp] + [Exp]]   {left}\n  Exp.Minus   = [[Exp] - [Exp]]   {left}\n\n  Exp.Eq      = [[Exp] = [Exp]]   {non-assoc}\n  Exp.Neq     = [[Exp] &lt;&gt; [Exp]]  {non-assoc}\n  Exp.Gt      = [[Exp] &gt; [Exp]]   {non-assoc}\n  Exp.Lt      = [[Exp] &lt; [Exp]]   {non-assoc}\n  Exp.Geq     = [[Exp] &gt;= [Exp]]  {non-assoc}\n  Exp.Leq     = [[Exp] &lt;= [Exp]]  {non-assoc}\n\n  Exp.And     = [[Exp] &amp; [Exp]]   {left}\n  Exp.Or      = [[Exp] | [Exp]]   {left}\n\n  //Exp = [([Exp])] {bracket, avoid}\n\ncontext-free priorities\n\n  // Precedence of operators: Unary minus has the highest\n  // precedence. The operators *, / have the next highest\n  // (tightest binding) precedence, followed by +, -, then\n  // by =, &lt;&gt;, &gt;, &lt;, &gt;=, &lt;=, then by &amp;, then by |.\n\n  // Associativity of operators: The operators *, /, +, -\n  // are all left associative. The comparison operators do\n  // not associate, so a = b = c is not a legal expression,\n  // a = (b = c) is legal.\n\n  {Exp.Uminus}\n  &gt; {left :\n    Exp.Times\n    Exp.Divide}\n  &gt; {left :\n    Exp.Plus\n    Exp.Minus}\n  &gt; {non-assoc :\n    Exp.Eq\n    Exp.Neq\n    Exp.Gt\n    Exp.Lt\n    Exp.Geq\n    Exp.Leq}\n  &gt; Exp.And\n  &gt; Exp.Or\n\n</code></pre> \u00d7"},{"location":"org.metaborg.lang.tiger.statix/syntax/Numbers.sdf3/#modal-h2","title":"Numbers.sdf3","text":""},{"location":"org.metaborg.lang.tiger.statix/syntax/Records.sdf3/","title":"<code>Records.sdf3</code>","text":"<p> pdmosses/metaborg-tiger/org.metaborg.lang.tiger.statix/syntax/Records.sdf3</p> <pre><code>module Records\n\nimports Base\n\nsorts Field InitField\n\n// Records\ncontext-free syntax\n\n  Type.RecordTy = &lt;\n    {\n       &lt;{Field \", \\n\"}*&gt;\n    }\n  &gt;\n\n  Field.Field = &lt;&lt;ID&gt; : &lt;ID&gt;&gt;\n\n  Exp.NilExp = &lt;nil&gt;\n\n  Exp.Record = &lt;&lt;ID&gt;{ &lt;{InitField \", \"}*&gt; }&gt;\n\n  InitField.InitField = &lt;&lt;ID&gt; = &lt;Exp&gt;&gt;\n\n  LValue.FieldVar = &lt;&lt;LValue&gt;.&lt;ID&gt;&gt;\n\n</code></pre> \u00d7"},{"location":"org.metaborg.lang.tiger.statix/syntax/Records.sdf3/#modal-h2","title":"Records.sdf3","text":""},{"location":"org.metaborg.lang.tiger.statix/syntax/Strings.sdf3/","title":"<code>Strings.sdf3</code>","text":"<p> pdmosses/metaborg-tiger/org.metaborg.lang.tiger.statix/syntax/Strings.sdf3</p> <pre><code>module Strings\n\nimports Base\n\nlexical sorts StrConst StrChar\n\nlexical syntax\n\n  StrConst = \"\\\"\" StrChar* \"\\\"\"\n  StrChar = ~[\\\\\\\"\\r\\n]\n  StrChar = [\\\\] [a]\n  StrChar = [\\\\] [b]\n  StrChar = [\\\\] [f]\n  StrChar = [\\\\] [n]\n  StrChar = [\\\\] [r]\n  StrChar = [\\\\] [t]\n  StrChar = [\\\\] [v]\n  StrChar = [\\\\] [\\^] [A-Z]\n  StrChar = [\\\\] [0-9] [0-9] [0-9]\n  StrChar = [\\\\] [x] [0-9a-fA-F] [0-9a-fA-F]\n  StrChar = [\\\\] [\\\\]\n  StrChar = [\\\\] [\\\"]\n\n  StrChar = [\\\\] [\\ \\t\\r\\n]+ [\\\\]\n\ncontext-free syntax\n\n  Exp.String = StrConst\n\n</code></pre> \u00d7"},{"location":"org.metaborg.lang.tiger.statix/syntax/Strings.sdf3/#modal-h2","title":"Strings.sdf3","text":""},{"location":"org.metaborg.lang.tiger.statix/syntax/Tiger.sdf3/","title":"<code>Tiger.sdf3</code>","text":"<p> pdmosses/metaborg-tiger/org.metaborg.lang.tiger.statix/syntax/Tiger.sdf3</p> <pre><code>module Tiger\n\nimports Base\nimports Whitespace\nimports Types\nimports Identifiers\nimports Bindings\nimports Variables\nimports Functions\nimports Numbers\nimports Strings\nimports Records\nimports Arrays\nimports Control-Flow\n\ncontext-free start-symbols Module\n\nsorts Module\ncontext-free syntax\n\n  Module.Mod = Exp\n\ncontext-free priorities\n\n  {\n    Exp.Or\n  } &gt; {\n    Exp.Array\n  } &gt; {\n    Exp.Assign\n  },\n\n  {\n    Exp.Uminus\n    LValue.FieldVar\n    LValue.Subscript\n  } &gt; {left:\n    Exp.Times\n    Exp.Divide\n  }\n\n</code></pre> \u00d7"},{"location":"org.metaborg.lang.tiger.statix/syntax/Tiger.sdf3/#modal-h2","title":"Tiger.sdf3","text":""},{"location":"org.metaborg.lang.tiger.statix/syntax/Types.sdf3/","title":"<code>Types.sdf3</code>","text":"<p> pdmosses/metaborg-tiger/org.metaborg.lang.tiger.statix/syntax/Types.sdf3</p> <pre><code>module Types\n\nimports Base\n\n// Type declarations\ncontext-free syntax\n\n  Dec.TypeDec = &lt;type &lt;ID&gt; = &lt;Type&gt;&gt;\n\n// Type expressions\ncontext-free syntax\n\n  Type.Tid = ID\n\n\n</code></pre> \u00d7"},{"location":"org.metaborg.lang.tiger.statix/syntax/Types.sdf3/#modal-h2","title":"Types.sdf3","text":""},{"location":"org.metaborg.lang.tiger.statix/syntax/Variables.sdf3/","title":"<code>Variables.sdf3</code>","text":"<p> pdmosses/metaborg-tiger/org.metaborg.lang.tiger.statix/syntax/Variables.sdf3</p> <pre><code>module Variables\n\nimports Base\n\n\ncontext-free syntax\n\n  Dec.VarDec = &lt;var &lt;ID&gt; : &lt;Type&gt; := &lt;Exp&gt;&gt;\n\n  Dec.VarDecNoType = &lt;var &lt;ID&gt; := &lt;Exp&gt;&gt;\n\n  Var.Var = ID\n\n  LValue = Var\n\n  Exp = LValue\n\n</code></pre> \u00d7"},{"location":"org.metaborg.lang.tiger.statix/syntax/Variables.sdf3/#modal-h2","title":"Variables.sdf3","text":""},{"location":"org.metaborg.lang.tiger.statix/syntax/Whitespace.sdf3/","title":"<code>Whitespace.sdf3</code>","text":"<p> pdmosses/metaborg-tiger/org.metaborg.lang.tiger.statix/syntax/Whitespace.sdf3</p> <pre><code>module Whitespace\n\nlexical sorts\n  CommentChar InsideComment SingleLineComment NewLineEOF EOF\n\nlexical syntax\n\n  LAYOUT         = [\\ \\t\\n\\r]\n  CommentChar    = [\\*]\n  LAYOUT         = \"/*\" InsideComment* \"*/\"\n  InsideComment  = ~[\\*]\n  InsideComment  = CommentChar\n  LAYOUT         = SingleLineComment\n  SingleLineComment = \"//\" ~[\\n\\r]* NewLineEOF\n  NewLineEOF     = [\\n\\r]\n  NewLineEOF     = EOF\n  EOF            =\n\nlexical restrictions\n\n  // Ensure greedy matching for lexicals\n\n  CommentChar   -/- [\\/]\n  EOF -/- ~[]\n\ncontext-free restrictions\n\n  // Ensure greedy matching for comments\n\n  LAYOUT? -/- [\\ \\t\\n\\r]\n  LAYOUT? -/- [\\/].[\\/]\n  LAYOUT? -/- [\\/].[\\*]\n\n</code></pre> \u00d7"},{"location":"org.metaborg.lang.tiger.statix/syntax/Whitespace.sdf3/#modal-h2","title":"Whitespace.sdf3","text":""},{"location":"org.metaborg.lang.tiger.statix/trans/static-semantics.stx/","title":"<code>static-semantics.stx</code>","text":"<p> pdmosses/metaborg-tiger/org.metaborg.lang.tiger.statix/trans/static-semantics.stx</p> <pre><code>module static-semantics\n\nimports\n  signatures/Tiger-sig\n\nrules // single-file entry point\n\n  programOk : Module\n\n  programOk(Mod(e)) :- {s T}\n    new s, init(s),\n    typeOfExp(s, e) == T.\n\nrules // multi-file entry point\n\n//  projectOk : scope\n//  projectOk(s).\n//  fileOk : scope * Start\n//  fileOk(s, Empty()).\n\nsignature // variables\n\n  sorts\n    VARS  = list((path * (ID * TYPE)))\n    TYPES = list((path * (ID * TYPE)))\n\n  relations\n    var   : ID -&gt; TYPE\n    type  : ID -&gt; TYPE\n\n  name-resolution\n    labels P\n\nsignature // records\n\n  sorts\n    FIELDS = list((path * (ID * TYPE)))\n\n  relations\n    field: ID -&gt; TYPE\n\nsignature // control-flow\n\n  relations\n    loop:\n\nrules // variable binding\n\n  declareVar : scope * ID *  TYPE\n  lookupVar  : scope * ID -&gt; VARS\n  typeOfVar  : scope * ID -&gt; TYPE\n\n  declareVar(s, x, T) :-\n    !var[x, T] in s,\n    // declaration is distinct\n    lookupVar(s, x) == [_],\n    @x.decl := x.\n\n  lookupVar(s, x) = VARs :-\n    query var\n      filter P*\n        and { x' :- x' == x }\n      min $ &lt; P\n       in s |-&gt; VARs.\n\n  typeOfVar(s, x) = T :- {x'}\n    // permissive lookup to cope with double declaration\n    lookupVar(s, x) == [(_, (x', T)) |_],\n    @x.ref := x'.\n\nrules // type binding\n\n  declareType : scope * ID * TYPE\n  lookupType  : scope * ID -&gt; TYPES\n  // no `typeOfType: scope * ID -&gt; TYPE` due to name clash\n\n  declareType(s, x, T) :-\n    !type[x, T] in s,\n    // declaration is distinct\n    lookupType(s, x) == [_],\n    @x.decl := x.\n\n  lookupType(s, x) = TYPES :-\n    query type\n      filter P*\n        and { x' :- x' == x }\n      min $ &lt; P\n       in s |-&gt; TYPES.\n\nrules // field binding\n\n  declareField      : scope * ID * TYPE\n  lookupField       : scope * ID        -&gt; FIELDS\n  lookupAllFields   : scope             -&gt; FIELDS\n  typeOfField       : scope * ID        -&gt; TYPE\n\n  declareField(s, x, T) :-\n    !field[x, T] in s,\n    // declaration is distinct\n    lookupField(s, x) == [_],\n    @x.decl := x.\n\n  lookupField(s, x) = FLDs :-\n    query field\n      filter P*\n        and { x' :- x' == x }\n      min $ &lt; P\n      in s |-&gt; FLDs.\n\n  lookupAllFields(s) = FLDs :-\n    query field\n      filter P*\n      min $ &lt; P\n      in s |-&gt; FLDs.\n\n  typeOfField(s, x) = T :- {d}\n    // permissive lookup to cope with double declaration\n    lookupField(s, x) == [(_, (d, T)) | _],\n    @x.ref := d.\n\nsignature\n  sorts TYPE\n  constructors\n    UNIT   : TYPE\n    INT    : TYPE\n    STRING : TYPE\n    NIL    : TYPE\n    RECORD : scope -&gt; TYPE\n    ARRAY  : TYPE * scope -&gt; TYPE\n    FUN    : list(TYPE) * TYPE -&gt; TYPE\n\nrules subtype : TYPE * TYPE\n\n  subtype(T, T).\n\n  subtype(NIL(), RECORD(s)).\n\nrules subtypes : list(TYPE) * list(TYPE)\n\n//  subtypes maps subtype(list(*), list(*))\n\n  subtypes([], []).\n\n  subtypes([T | Ts], [S | Ss]) :-\n    subtype(T, S),\n    subtypes(Ts, Ss).\n\nrules equitype : TYPE * TYPE\n\n  equitype(T, T).\n  equitype(NIL(), RECORD(s)).\n  equitype(RECORD(s), NIL()).\n\n  lub : TYPE * TYPE -&gt; TYPE\n  lub(S, T) = S.\n  lub(NIL(), T) = T.\n\nrules\n\n  typeOfExp  : scope * Exp -&gt; TYPE\n  typeOfExps   maps typeOfExp(*, list(*)) = list(*)\n\n\n  typeOfSeq  : scope * list(Exp) -&gt; TYPE\n  typeOfLVal : scope * LValue -&gt; TYPE\n\nrules\n\n  typeOfExp(s_outer, Let(ds, es)) = T :- {s_body s_dec}\n    new s_body,\n    new s_dec,\n    s_dec -P-&gt; s_outer,\n    decsOk(s_body, s_dec, ds),\n    typeOfSeq(s_body, es) == T.\n\n\n  decsOk     : scope * scope * list(Dec)\n  decOk      : scope * scope * Dec\n\n\n  decsOk(s_body, s_outer, [dec@VarDec(_, _, _) | decs]) :- {s_dec}\n    new s_dec,\n    s_dec -P-&gt; s_outer,\n    decOk(s_dec, s_outer, dec),\n    decsOk(s_body, s_dec, decs).\n\n  decsOk(s_body, s_outer, [dec@VarDecNoType(_, _) | decs]) :- {s_dec}\n    new s_dec,\n    s_dec -P-&gt; s_outer,\n    decOk(s_dec, s_outer, dec),\n    decsOk(s_body, s_dec, decs).\n\n  decsOk(s_body, s_outer, [dec | decs]) :- {s_dec}\n    decOk(s_outer, s_outer, dec),\n    decsOk(s_body, s_outer, decs).\n\n  decsOk(s_body, s_outer, []) :-\n    s_body -P-&gt; s_outer.\n\nrules // type declarations\n\n  // Types: In the expression [let ... typedecs ... in exps end] the\n  // scope of a type identifier starts at the beginning of the\n  // consecutive sequence of type declarations defining it and lasts\n  // until the end. The includes the headers and bodies of any functions\n  // with the scope.\n\n  // Name spaces: There are two different name spaces: one for types,\n  // and one for functions and variables. A type [a] can be \"in scope\"\n  // at the same time as a variable [a] or a function [a], but\n  // variables and functions of the same name cannot both be in\n  // scope simultaneously (one will hide the other).\n\n  decOk(s, s_outer, TypeDec(x, t)) :- {T}\n    typeOfType(s_outer, t) == T,\n    declareType(s, x, T).\n\n   // note: type declarations in a sequence are mutually recursive\n\nrules // types\n\n  typeOfType : scope * Type -&gt; TYPE\n\n  typeOfType(s, Tid(x)) = T :- {x'}\n    // permissive lookup to cope with double declaration\n    lookupType(s, x) == [(_, (x', T)) | _],\n    @x.ref := x'.\n\n    // typeOfDecl of Type{x} in s |-&gt; [(_, (_, T))|_].\n    // permissive query to allow non-distinct type declarations\n\nrules // function declarations\n\n  // Parameters: In [function id(... id1: id2 ...) = exp] the\n  // scope of the parameter id1 lasts throughout the function\n  // body exp\n\n  decOk(s, s_outer, d@ProcDec(f, args, e)) :- {s_fun Ts}\n    new s_fun, s_fun -P-&gt; s,\n    typesOfArgs(s_fun, s_outer, args) == Ts,\n    declareVar(s, f, FUN(Ts, UNIT())),\n    typeOfExp(s_fun, e) == UNIT().\n\n  decOk(s, s_outer, d@FunDec(f, args, t, e)) :- {s_fun Ts T S}\n    new s_fun, s_fun -P-&gt; s,\n    typesOfArgs(s_fun, s_outer, args) == Ts,\n    typeOfType(s_outer, t) == T,\n    declareVar(s, f, FUN(Ts, T)),\n    typeOfExp(s_fun, e) == S,\n    subtype(S, T) | error $[[S] is not a subtype of [T]] @t.\n\nrules\n  typeOfArg  : scope * scope * FArg -&gt; TYPE\n  typesOfArgs  maps typeOfArg(*, *, list(*)) = list(*)\n\n  typeOfArg(s_fun, s_outer, FArg(x, t)) = T :-\n    typeOfType(s_outer, t) == T,\n    declareVar(s_fun, x, T).\n\nrules // function calls\n\n  typeOfExp(s, Call(f, es)) = T :- {Ts Ss}\n    typeOfVar(s, f) == FUN(Ts, T),\n    typeOfExps(s, es) == Ss,\n    subtypes(Ss, Ts).\n\nrules // variable declarations\n\n  // Local variables: In the expression [let ... vardec ... in exp end],\n  // the scope of the declared variable starts just after its vardec\n  // and lasts until the end.\n\n  decOk(s, s_outer, VarDec(x, t, e)) :- {T S}\n    typeOfType(s_outer, t) == T,\n    typeOfExp(s_outer, e) == S,\n    subtype(S, T),\n    declareVar(s, x, T).\n\n  decOk(s, s_outer, VarDecNoType(x, e)) :- {T}\n    typeOfExp(s_outer, e) == T,\n    T != NIL(),\n    declareVar(s, x, T).\n\nrules // arrays\n\n  typeOfType(s, ArrayTy(x)) = ARRAY(T, s_arr) :-\n    new s_arr, // unique token to distinghuish the array type\n    typeOfType(s, Tid(x)) == T.\n\nrules // array creation\n\n  typeOfExp(s, Array(x, e1, e2)) = ARRAY(T, s_arr) :- {S}\n    typeOfType(s, Tid(x)) == ARRAY(T, s_arr),\n    typeOfExp(s, e1) == INT(),\n    typeOfExp(s, e2) == S,\n    subtype(S, T).\n\nrules // array indexing\n\n  typeOfLVal(s, Subscript(e1, e2)) = T :- {s_arr}\n    typeOfLVal(s, e1) == ARRAY(T, s_arr),\n    typeOfExp(s, e2) == INT().\n\nrules // statements\n\n  typeOfExp(s, Assign(e1, e2)) = UNIT() :- {T S}\n    typeOfLVal(s, e1) == T,\n    typeOfExp(s, e2) == S,\n    subtype(S, T).\n\nrules\n\n  typeOfLVal(s, Var2LValue(Var(x))) = T :-\n    typeOfVar(s, x) == T.\n\n  typeOfExp(s, LValue2Exp(lval)) = typeOfLVal(s, lval).\n\n  typeOfExp(s, LValue2Exp(Var2LValue(Var(x)))) = typeOfVar(s, x).\n\nrules // sequence\n\n  typeOfSeq(s, []) = UNIT().\n\n  typeOfSeq(s, [e]) = T :-\n    typeOfExp(s, e) == T.\n\n  typeOfSeq(s, [e | es@[_|_]]) = T :- {S}\n    typeOfExp(s, e) == S,\n    typeOfSeq(s, es) == T.\n\n  typeOfExp(s, Seq(es)) = typeOfSeq(s, es).\n\n  typeOfExp(s, If(e1, e2, e3)) = lub(T, S) :-\n    typeOfExp(s, e1) == INT(),\n    typeOfExp(s, e2) == T,\n    typeOfExp(s, e3) == S,\n    equitype(S, T).\n\n  typeOfExp(s, IfThen(e1, e2)) = UNIT() :-\n    typeOfExp(s, e1) == INT(),\n    typeOfExp(s, e2) == UNIT().\n\n  typeOfExp(s, While(e1, e2)) = UNIT() :- {s_loop}\n    new s_loop, s_loop -P-&gt; s,\n    !loop[] in s_loop,\n    typeOfExp(s_loop, e1) == INT(),\n    typeOfExp(s_loop, e2) == UNIT().\n\n  typeOfExp(s, For(Var(x), e1, e2, e3)) = UNIT() :- {s_for}\n    new s_for,\n    s_for -P-&gt; s,\n    declareVar(s_for, x, INT()),\n    !loop[] in s_for,\n    typeOfExp(s, e1) == INT(),\n    typeOfExp(s, e2) == INT(),\n    typeOfExp(s_for, e3) == UNIT().\n\n  typeOfExp(s, Break()) = UNIT() :-\n    query loop\n      filter P*\n      min $ &lt; P\n       in s |-&gt; [_].\n\nrules // literals\n\n  typeOfExp(s, Int(i)) = INT() :-\n    @i.lit := i.\n\nrules // operators\n\n  typeOfExp(s, Uminus(e)) = INT() :-\n    typeOfExp(s, e) == INT().\n\n  typeOfExp(s, Divide(e1, e2)) = INT() :-\n    typeOfExp(s, e1) == INT(),\n    typeOfExp(s, e2) == INT().\n\n  typeOfExp(s, Times(e1, e2)) = INT() :-\n    typeOfExp(s, e1) == INT(),\n    typeOfExp(s, e2) == INT().\n\n  typeOfExp(s, Minus(e1, e2)) = INT() :-\n    typeOfExp(s, e1) == INT(),\n    typeOfExp(s, e2) == INT().\n\n  typeOfExp(s, Plus(e1, e2)) = INT() :-\n    typeOfExp(s, e1) == INT(),\n    typeOfExp(s, e2) == INT().\n\n  typeOfExp(s, Eq(e1, e2)) = INT() :- {T S}\n    typeOfExp(s, e1) == T,\n    typeOfExp(s, e2) == S,\n    equitype(T, S).\n    // TODO: does Eq work for all types?\n\n  typeOfExp(s, Neq(e1, e2)) = INT() :- {T S}\n    typeOfExp(s, e1) == T,\n    typeOfExp(s, e2) == S,\n    equitype(T, S).\n    // TODO: does Neq work for all types?\n\n  typeOfExp(s, Gt(e1, e2)) = INT() :-\n    typeOfExp(s, e1) == INT(),\n    typeOfExp(s, e2) == INT().\n    // TODO: does Gt work for more types?\n\n  typeOfExp(s, Lt(e1, e2)) = INT() :-\n    typeOfExp(s, e1) == INT(),\n    typeOfExp(s, e2) == INT().\n\n  typeOfExp(s, Geq(e1, e2)) = INT() :-\n    typeOfExp(s, e1) == INT(),\n    typeOfExp(s, e2) == INT().\n\n  typeOfExp(s, Leq(e1, e2)) = INT() :-\n    typeOfExp(s, e1) == INT(),\n    typeOfExp(s, e2) == INT().\n\n  typeOfExp(s, Or(e1, e2)) = INT() :-\n    typeOfExp(s, e1) == INT(),\n    typeOfExp(s, e2) == INT().\n\n  typeOfExp(s, And(e1, e2)) = INT() :-\n    typeOfExp(s, e1) == INT(),\n    typeOfExp(s, e2) == INT().\n\nrules // record type\n\n  typeOfType(s, RecordTy(fields)) = RECORD(s_rec) :-\n    new s_rec,\n    fieldsOk(s_rec, s, fields).\n\n  fieldOk : scope * scope * Field\n  fieldsOk maps fieldOk(*, *, list(*))\n\n  fieldOk(s_rec, s_outer, Field(x, t)) :- {T}\n    typeOfType(s_outer, Tid(t)) == T,\n    declareField(s_rec, x, T).\n\nrules // literals\n\n  typeOfExp(s, NilExp()) = NIL().\n\nrules // record creation\n\n  typeOfExp(s, e@Record(t, inits)) = RECORD(s_rec) :- {s_init ds}\n    typeOfType(s, Tid(t)) == RECORD(s_rec),\n    new s_init,\n    initsOk(s, s_rec, s_init, inits),\n    lookupAllFields(s_rec) == ds,\n    fieldsSameLength(ds, inits),\n    allFieldsInitialized(t, ds, s_init).\n\n\n  fieldsSameLength : list((path * (ID * TYPE))) * list(InitField)\n  fieldsSameLength([],[]).\n  fieldsSameLength([_|xs], [_|ys]) :- fieldsSameLength(xs, ys).\n\n\n\n  initOk : scope * scope * scope * InitField\n  initsOk maps initOk(*, *, *, list(*))\n\n  initOk(s, s_rec, s_init, InitField(x, e)) :- {S T}\n    typeOfField(s_rec, x) == T,\n    typeOfExp(s, e) == S,\n    declareField(s_init, x, S),\n    subtype(S, T).\n\n  fieldInitialized : ID * (path * (ID * TYPE)) * scope\n  allFieldsInitialized maps fieldInitialized(*, list(*), *)\n\n  fieldInitialized(t, (_, (x, _)), s) :-\n    lookupField(s, x) == [_].\n    // t is passed such that error is displayed be on t;\n    // noting that init of x is missing\n\nrules // record field access\n\n  typeOfLVal(s, FieldVar(lval, x)) = T :- {s_rec}\n    typeOfLVal(s, lval) == RECORD(s_rec),\n    typeOfField(s_rec, x) == T.\n\nrules // literals\n\n  typeOfExp(s, String(v)) = STRING() :-\n    @v.lit := v.\n\nrules\n\n  init : scope\n\n  init(s) :-\n    declareType(s, \"int\",    INT()),\n    declareType(s, \"string\", STRING()),\n\n    declareVar(s,  \"print\",     FUN([STRING()], UNIT())),\n    declareVar(s,  \"chr\",       FUN([INT()], STRING())),\n    declareVar(s,  \"ord\",       FUN([STRING()], INT())),\n    declareVar(s,  \"size\",      FUN([STRING()], INT())),\n    declareVar(s,  \"substring\", FUN([STRING(), INT(), INT()], STRING())),\n    declareVar(s,  \"concat\",    FUN([STRING(), STRING()], STRING())),\n    declareVar(s,  \"not\",       FUN([INT()], INT())),\n    declareVar(s,  \"exit\",      FUN([INT()], UNIT())),\n    declareVar(s,  \"getchar\",   FUN([], STRING())),\n    declareVar(s,  \"flush\",     FUN([], UNIT())),\n    declareVar(s,  \"printi\",    FUN([INT()], UNIT())),\n\n    // For benchmarks\n    declareVar(s,  \"timeGo\",    FUN([], UNIT())),\n    declareVar(s,  \"timeStop\",  FUN([], UNIT())).\n\n\n\nrules // placeholders\n\n  programOk(Module-Plhdr()).\n\n  initOk(_, _, _, InitField-Plhdr()).\n\n  //declareField(_, TypeId-Plhdr(), T).\n\n  typeOfLVal(_, LValue-Plhdr()) = T.\n\n  decOk(_, _, Dec-Plhdr()).\n\n  typeOfType(_, Type-Plhdr()) = T.\n\n  typeOfArg(_, _, FArg-Plhdr()) = T.\n\n  //fieldInitialized(TypeId-Plhdr(), _, _).\n\n  fieldOk(_, _, Field-Plhdr()).\n\n  typeOfExp(_, Exp-Plhdr()) = T.\n\n</code></pre> \u00d7"},{"location":"org.metaborg.lang.tiger.statix/trans/static-semantics.stx/#modal-h2","title":"static-semantics.stx","text":""}]}